{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createWeb3ReactStoreAndActions = exports.ChainIdNotAllowedError = exports.MAX_SAFE_CHAIN_ID = void 0;\n\nconst address_1 = require(\"@ethersproject/address\");\n\nconst vanilla_1 = __importDefault(require(\"zustand/vanilla\"));\n/**\n * MAX_SAFE_CHAIN_ID is the upper bound limit on what will be accepted for `chainId`\n * `MAX_SAFE_CHAIN_ID = floor( ( 2**53 - 39 ) / 2 ) = 4503599627370476`\n *\n * @see {@link https://github.com/MetaMask/metamask-extension/blob/b6673731e2367e119a5fee9a454dd40bd4968948/shared/constants/network.js#L31}\n */\n\n\nexports.MAX_SAFE_CHAIN_ID = 4503599627370476;\n\nfunction validateChainId(chainId) {\n  if (!Number.isInteger(chainId) || chainId <= 0 || chainId > exports.MAX_SAFE_CHAIN_ID) {\n    throw new Error(`Invalid chainId ${chainId}`);\n  }\n}\n\nclass ChainIdNotAllowedError extends Error {\n  constructor(chainId, allowedChainIds) {\n    super(`chainId ${chainId} not included in ${allowedChainIds.toString()}`);\n    this.chainId = chainId;\n    this.name = ChainIdNotAllowedError.name;\n    Object.setPrototypeOf(this, ChainIdNotAllowedError.prototype);\n  }\n\n}\n\nexports.ChainIdNotAllowedError = ChainIdNotAllowedError;\n\nfunction ensureChainIdIsAllowed(chainId, allowedChainIds) {\n  return allowedChainIds.some(allowedChainId => chainId === allowedChainId) ? undefined : new ChainIdNotAllowedError(chainId, allowedChainIds);\n}\n\nfunction validateAccount(account) {\n  return (0, address_1.getAddress)(account);\n}\n\nconst DEFAULT_STATE = {\n  chainId: undefined,\n  accounts: undefined,\n  activating: false,\n  error: undefined\n};\n\nfunction createWeb3ReactStoreAndActions(allowedChainIds) {\n  if ((allowedChainIds === null || allowedChainIds === void 0 ? void 0 : allowedChainIds.length) === 0) {\n    throw new Error(`allowedChainIds is length 0`);\n  }\n\n  const store = (0, vanilla_1.default)(() => DEFAULT_STATE); // flag for tracking updates so we don't clobber data when cancelling activation\n\n  let nullifier = 0;\n  /**\n   * Sets activating to true, indicating that an update is in progress.\n   *\n   * @returns cancelActivation - A function that cancels the activation by setting activating to false,\n   * as long as there haven't been any intervening updates.\n   */\n\n  function startActivation() {\n    const nullifierCached = ++nullifier;\n    store.setState(Object.assign(Object.assign({}, DEFAULT_STATE), {\n      activating: true\n    })); // return a function that cancels the activation iff nothing else has happened\n\n    return () => {\n      if (nullifier === nullifierCached) store.setState({\n        activating: false\n      });\n    };\n  }\n  /**\n   * Used to report a `stateUpdate` which is merged with existing state. The first `stateUpdate` that results in chainId\n   * and accounts being set will also set activating to false, indicating a successful connection. Similarly, if an\n   * error is set, the first `stateUpdate` that results in chainId and accounts being set will clear this error.\n   *\n   * @param stateUpdate - The state update to report.\n   */\n\n\n  function update(stateUpdate) {\n    // validate chainId statically, independent of existing state\n    if (stateUpdate.chainId !== undefined) {\n      validateChainId(stateUpdate.chainId);\n    } // validate accounts statically, independent of existing state\n\n\n    if (stateUpdate.accounts !== undefined) {\n      for (let i = 0; i < stateUpdate.accounts.length; i++) {\n        stateUpdate.accounts[i] = validateAccount(stateUpdate.accounts[i]);\n      }\n    }\n\n    nullifier++;\n    store.setState(existingState => {\n      var _a, _b; // determine the next chainId and accounts\n\n\n      const chainId = (_a = stateUpdate.chainId) !== null && _a !== void 0 ? _a : existingState.chainId;\n      const accounts = (_b = stateUpdate.accounts) !== null && _b !== void 0 ? _b : existingState.accounts; // determine the next error\n\n      let error = existingState.error;\n\n      if (chainId && allowedChainIds) {\n        // if we have a chainId allowlist and a chainId, we need to ensure it's allowed\n        const chainIdError = ensureChainIdIsAllowed(chainId, allowedChainIds); // warn if we're going to clobber existing error\n\n        if (chainIdError && error) {\n          if (!(error instanceof ChainIdNotAllowedError) || error.chainId !== chainIdError.chainId) {\n            console.debug(`${error.name} is being clobbered by ${chainIdError.name}`);\n          }\n        }\n\n        error = chainIdError;\n      } // ensure that the error is cleared when appropriate\n\n\n      if (error && !(error instanceof ChainIdNotAllowedError) && chainId && accounts) {\n        error = undefined;\n      } // ensure that the activating flag is cleared when appropriate\n\n\n      let activating = existingState.activating;\n\n      if (activating && (error || chainId && accounts)) {\n        activating = false;\n      }\n\n      return {\n        chainId,\n        accounts,\n        activating,\n        error\n      };\n    });\n  }\n  /**\n   * Used to report an `error`, which clears all existing state.\n   *\n   * @param error - The error to report. If undefined, the state will be reset to its default value.\n   */\n\n\n  function reportError(error) {\n    nullifier++;\n    store.setState(() => Object.assign(Object.assign({}, DEFAULT_STATE), {\n      error\n    }));\n  }\n\n  return [store, {\n    startActivation,\n    update,\n    reportError\n  }];\n}\n\nexports.createWeb3ReactStoreAndActions = createWeb3ReactStoreAndActions;","map":{"version":3,"sources":["/Users/computer/code/avalanche/web3-react/packages/store/dist/index.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","createWeb3ReactStoreAndActions","ChainIdNotAllowedError","MAX_SAFE_CHAIN_ID","address_1","require","vanilla_1","validateChainId","chainId","Number","isInteger","Error","constructor","allowedChainIds","toString","name","setPrototypeOf","prototype","ensureChainIdIsAllowed","some","allowedChainId","undefined","validateAccount","account","getAddress","DEFAULT_STATE","accounts","activating","error","length","store","default","nullifier","startActivation","nullifierCached","setState","assign","update","stateUpdate","i","existingState","_a","_b","chainIdError","console","debug","reportError"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,8BAAR,GAAyCF,OAAO,CAACG,sBAAR,GAAiCH,OAAO,CAACI,iBAAR,GAA4B,KAAK,CAA3G;;AACA,MAAMC,SAAS,GAAGC,OAAO,CAAC,wBAAD,CAAzB;;AACA,MAAMC,SAAS,GAAGZ,eAAe,CAACW,OAAO,CAAC,iBAAD,CAAR,CAAjC;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,OAAO,CAACI,iBAAR,GAA4B,gBAA5B;;AACA,SAASI,eAAT,CAAyBC,OAAzB,EAAkC;AAC9B,MAAI,CAACC,MAAM,CAACC,SAAP,CAAiBF,OAAjB,CAAD,IAA8BA,OAAO,IAAI,CAAzC,IAA8CA,OAAO,GAAGT,OAAO,CAACI,iBAApE,EAAuF;AACnF,UAAM,IAAIQ,KAAJ,CAAW,mBAAkBH,OAAQ,EAArC,CAAN;AACH;AACJ;;AACD,MAAMN,sBAAN,SAAqCS,KAArC,CAA2C;AACvCC,EAAAA,WAAW,CAACJ,OAAD,EAAUK,eAAV,EAA2B;AAClC,UAAO,WAAUL,OAAQ,oBAAmBK,eAAe,CAACC,QAAhB,EAA2B,EAAvE;AACA,SAAKN,OAAL,GAAeA,OAAf;AACA,SAAKO,IAAL,GAAYb,sBAAsB,CAACa,IAAnC;AACAlB,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4Bd,sBAAsB,CAACe,SAAnD;AACH;;AANsC;;AAQ3ClB,OAAO,CAACG,sBAAR,GAAiCA,sBAAjC;;AACA,SAASgB,sBAAT,CAAgCV,OAAhC,EAAyCK,eAAzC,EAA0D;AACtD,SAAOA,eAAe,CAACM,IAAhB,CAAsBC,cAAD,IAAoBZ,OAAO,KAAKY,cAArD,IACDC,SADC,GAED,IAAInB,sBAAJ,CAA2BM,OAA3B,EAAoCK,eAApC,CAFN;AAGH;;AACD,SAASS,eAAT,CAAyBC,OAAzB,EAAkC;AAC9B,SAAO,CAAC,GAAGnB,SAAS,CAACoB,UAAd,EAA0BD,OAA1B,CAAP;AACH;;AACD,MAAME,aAAa,GAAG;AAClBjB,EAAAA,OAAO,EAAEa,SADS;AAElBK,EAAAA,QAAQ,EAAEL,SAFQ;AAGlBM,EAAAA,UAAU,EAAE,KAHM;AAIlBC,EAAAA,KAAK,EAAEP;AAJW,CAAtB;;AAMA,SAASpB,8BAAT,CAAwCY,eAAxC,EAAyD;AACrD,MAAI,CAACA,eAAe,KAAK,IAApB,IAA4BA,eAAe,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,eAAe,CAACgB,MAAnF,MAA+F,CAAnG,EAAsG;AAClG,UAAM,IAAIlB,KAAJ,CAAW,6BAAX,CAAN;AACH;;AACD,QAAMmB,KAAK,GAAG,CAAC,GAAGxB,SAAS,CAACyB,OAAd,EAAuB,MAAMN,aAA7B,CAAd,CAJqD,CAKrD;;AACA,MAAIO,SAAS,GAAG,CAAhB;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI,WAASC,eAAT,GAA2B;AACvB,UAAMC,eAAe,GAAG,EAAEF,SAA1B;AACAF,IAAAA,KAAK,CAACK,QAAN,CAAetC,MAAM,CAACuC,MAAP,CAAcvC,MAAM,CAACuC,MAAP,CAAc,EAAd,EAAkBX,aAAlB,CAAd,EAAgD;AAAEE,MAAAA,UAAU,EAAE;AAAd,KAAhD,CAAf,EAFuB,CAGvB;;AACA,WAAO,MAAM;AACT,UAAIK,SAAS,KAAKE,eAAlB,EACIJ,KAAK,CAACK,QAAN,CAAe;AAAER,QAAAA,UAAU,EAAE;AAAd,OAAf;AACP,KAHD;AAIH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACI,WAASU,MAAT,CAAgBC,WAAhB,EAA6B;AACzB;AACA,QAAIA,WAAW,CAAC9B,OAAZ,KAAwBa,SAA5B,EAAuC;AACnCd,MAAAA,eAAe,CAAC+B,WAAW,CAAC9B,OAAb,CAAf;AACH,KAJwB,CAKzB;;;AACA,QAAI8B,WAAW,CAACZ,QAAZ,KAAyBL,SAA7B,EAAwC;AACpC,WAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,WAAW,CAACZ,QAAZ,CAAqBG,MAAzC,EAAiDU,CAAC,EAAlD,EAAsD;AAClDD,QAAAA,WAAW,CAACZ,QAAZ,CAAqBa,CAArB,IAA0BjB,eAAe,CAACgB,WAAW,CAACZ,QAAZ,CAAqBa,CAArB,CAAD,CAAzC;AACH;AACJ;;AACDP,IAAAA,SAAS;AACTF,IAAAA,KAAK,CAACK,QAAN,CAAgBK,aAAD,IAAmB;AAC9B,UAAIC,EAAJ,EAAQC,EAAR,CAD8B,CAE9B;;;AACA,YAAMlC,OAAO,GAAG,CAACiC,EAAE,GAAGH,WAAW,CAAC9B,OAAlB,MAA+B,IAA/B,IAAuCiC,EAAE,KAAK,KAAK,CAAnD,GAAuDA,EAAvD,GAA4DD,aAAa,CAAChC,OAA1F;AACA,YAAMkB,QAAQ,GAAG,CAACgB,EAAE,GAAGJ,WAAW,CAACZ,QAAlB,MAAgC,IAAhC,IAAwCgB,EAAE,KAAK,KAAK,CAApD,GAAwDA,EAAxD,GAA6DF,aAAa,CAACd,QAA5F,CAJ8B,CAK9B;;AACA,UAAIE,KAAK,GAAGY,aAAa,CAACZ,KAA1B;;AACA,UAAIpB,OAAO,IAAIK,eAAf,EAAgC;AAC5B;AACA,cAAM8B,YAAY,GAAGzB,sBAAsB,CAACV,OAAD,EAAUK,eAAV,CAA3C,CAF4B,CAG5B;;AACA,YAAI8B,YAAY,IAAIf,KAApB,EAA2B;AACvB,cAAI,EAAEA,KAAK,YAAY1B,sBAAnB,KAA8C0B,KAAK,CAACpB,OAAN,KAAkBmC,YAAY,CAACnC,OAAjF,EAA0F;AACtFoC,YAAAA,OAAO,CAACC,KAAR,CAAe,GAAEjB,KAAK,CAACb,IAAK,0BAAyB4B,YAAY,CAAC5B,IAAK,EAAvE;AACH;AACJ;;AACDa,QAAAA,KAAK,GAAGe,YAAR;AACH,OAjB6B,CAkB9B;;;AACA,UAAIf,KAAK,IAAI,EAAEA,KAAK,YAAY1B,sBAAnB,CAAT,IAAuDM,OAAvD,IAAkEkB,QAAtE,EAAgF;AAC5EE,QAAAA,KAAK,GAAGP,SAAR;AACH,OArB6B,CAsB9B;;;AACA,UAAIM,UAAU,GAAGa,aAAa,CAACb,UAA/B;;AACA,UAAIA,UAAU,KAAKC,KAAK,IAAKpB,OAAO,IAAIkB,QAA1B,CAAd,EAAoD;AAChDC,QAAAA,UAAU,GAAG,KAAb;AACH;;AACD,aAAO;AAAEnB,QAAAA,OAAF;AAAWkB,QAAAA,QAAX;AAAqBC,QAAAA,UAArB;AAAiCC,QAAAA;AAAjC,OAAP;AACH,KA5BD;AA6BH;AACD;AACJ;AACA;AACA;AACA;;;AACI,WAASkB,WAAT,CAAqBlB,KAArB,EAA4B;AACxBI,IAAAA,SAAS;AACTF,IAAAA,KAAK,CAACK,QAAN,CAAe,MAAOtC,MAAM,CAACuC,MAAP,CAAcvC,MAAM,CAACuC,MAAP,CAAc,EAAd,EAAkBX,aAAlB,CAAd,EAAgD;AAAEG,MAAAA;AAAF,KAAhD,CAAtB;AACH;;AACD,SAAO,CAACE,KAAD,EAAQ;AAAEG,IAAAA,eAAF;AAAmBI,IAAAA,MAAnB;AAA2BS,IAAAA;AAA3B,GAAR,CAAP;AACH;;AACD/C,OAAO,CAACE,8BAAR,GAAyCA,8BAAzC","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createWeb3ReactStoreAndActions = exports.ChainIdNotAllowedError = exports.MAX_SAFE_CHAIN_ID = void 0;\nconst address_1 = require(\"@ethersproject/address\");\nconst vanilla_1 = __importDefault(require(\"zustand/vanilla\"));\n/**\n * MAX_SAFE_CHAIN_ID is the upper bound limit on what will be accepted for `chainId`\n * `MAX_SAFE_CHAIN_ID = floor( ( 2**53 - 39 ) / 2 ) = 4503599627370476`\n *\n * @see {@link https://github.com/MetaMask/metamask-extension/blob/b6673731e2367e119a5fee9a454dd40bd4968948/shared/constants/network.js#L31}\n */\nexports.MAX_SAFE_CHAIN_ID = 4503599627370476;\nfunction validateChainId(chainId) {\n    if (!Number.isInteger(chainId) || chainId <= 0 || chainId > exports.MAX_SAFE_CHAIN_ID) {\n        throw new Error(`Invalid chainId ${chainId}`);\n    }\n}\nclass ChainIdNotAllowedError extends Error {\n    constructor(chainId, allowedChainIds) {\n        super(`chainId ${chainId} not included in ${allowedChainIds.toString()}`);\n        this.chainId = chainId;\n        this.name = ChainIdNotAllowedError.name;\n        Object.setPrototypeOf(this, ChainIdNotAllowedError.prototype);\n    }\n}\nexports.ChainIdNotAllowedError = ChainIdNotAllowedError;\nfunction ensureChainIdIsAllowed(chainId, allowedChainIds) {\n    return allowedChainIds.some((allowedChainId) => chainId === allowedChainId)\n        ? undefined\n        : new ChainIdNotAllowedError(chainId, allowedChainIds);\n}\nfunction validateAccount(account) {\n    return (0, address_1.getAddress)(account);\n}\nconst DEFAULT_STATE = {\n    chainId: undefined,\n    accounts: undefined,\n    activating: false,\n    error: undefined,\n};\nfunction createWeb3ReactStoreAndActions(allowedChainIds) {\n    if ((allowedChainIds === null || allowedChainIds === void 0 ? void 0 : allowedChainIds.length) === 0) {\n        throw new Error(`allowedChainIds is length 0`);\n    }\n    const store = (0, vanilla_1.default)(() => DEFAULT_STATE);\n    // flag for tracking updates so we don't clobber data when cancelling activation\n    let nullifier = 0;\n    /**\n     * Sets activating to true, indicating that an update is in progress.\n     *\n     * @returns cancelActivation - A function that cancels the activation by setting activating to false,\n     * as long as there haven't been any intervening updates.\n     */\n    function startActivation() {\n        const nullifierCached = ++nullifier;\n        store.setState(Object.assign(Object.assign({}, DEFAULT_STATE), { activating: true }));\n        // return a function that cancels the activation iff nothing else has happened\n        return () => {\n            if (nullifier === nullifierCached)\n                store.setState({ activating: false });\n        };\n    }\n    /**\n     * Used to report a `stateUpdate` which is merged with existing state. The first `stateUpdate` that results in chainId\n     * and accounts being set will also set activating to false, indicating a successful connection. Similarly, if an\n     * error is set, the first `stateUpdate` that results in chainId and accounts being set will clear this error.\n     *\n     * @param stateUpdate - The state update to report.\n     */\n    function update(stateUpdate) {\n        // validate chainId statically, independent of existing state\n        if (stateUpdate.chainId !== undefined) {\n            validateChainId(stateUpdate.chainId);\n        }\n        // validate accounts statically, independent of existing state\n        if (stateUpdate.accounts !== undefined) {\n            for (let i = 0; i < stateUpdate.accounts.length; i++) {\n                stateUpdate.accounts[i] = validateAccount(stateUpdate.accounts[i]);\n            }\n        }\n        nullifier++;\n        store.setState((existingState) => {\n            var _a, _b;\n            // determine the next chainId and accounts\n            const chainId = (_a = stateUpdate.chainId) !== null && _a !== void 0 ? _a : existingState.chainId;\n            const accounts = (_b = stateUpdate.accounts) !== null && _b !== void 0 ? _b : existingState.accounts;\n            // determine the next error\n            let error = existingState.error;\n            if (chainId && allowedChainIds) {\n                // if we have a chainId allowlist and a chainId, we need to ensure it's allowed\n                const chainIdError = ensureChainIdIsAllowed(chainId, allowedChainIds);\n                // warn if we're going to clobber existing error\n                if (chainIdError && error) {\n                    if (!(error instanceof ChainIdNotAllowedError) || error.chainId !== chainIdError.chainId) {\n                        console.debug(`${error.name} is being clobbered by ${chainIdError.name}`);\n                    }\n                }\n                error = chainIdError;\n            }\n            // ensure that the error is cleared when appropriate\n            if (error && !(error instanceof ChainIdNotAllowedError) && chainId && accounts) {\n                error = undefined;\n            }\n            // ensure that the activating flag is cleared when appropriate\n            let activating = existingState.activating;\n            if (activating && (error || (chainId && accounts))) {\n                activating = false;\n            }\n            return { chainId, accounts, activating, error };\n        });\n    }\n    /**\n     * Used to report an `error`, which clears all existing state.\n     *\n     * @param error - The error to report. If undefined, the state will be reset to its default value.\n     */\n    function reportError(error) {\n        nullifier++;\n        store.setState(() => (Object.assign(Object.assign({}, DEFAULT_STATE), { error })));\n    }\n    return [store, { startActivation, update, reportError }];\n}\nexports.createWeb3ReactStoreAndActions = createWeb3ReactStoreAndActions;\n"]},"metadata":{},"sourceType":"script"}