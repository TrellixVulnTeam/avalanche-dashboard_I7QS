System.register([],function(w){"use strict";return{execute:function(){w("devtools",x);var j=Object.defineProperty,E=Object.getOwnPropertySymbols,D=Object.prototype.hasOwnProperty,N=Object.prototype.propertyIsEnumerable,P=(n,r,e)=>r in n?j(n,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[r]=e,R=(n,r)=>{for(var e in r||(r={}))D.call(r,e)&&P(n,e,r[e]);if(E)for(var e of E(r))N.call(r,e)&&P(n,e,r[e]);return n};const F=w("redux",(n,r)=>(e,s,o)=>(o.dispatch=a=>(e(h=>n(h,a),!1,a),a),o.dispatchFromDevtools=!0,R({dispatch:(...a)=>o.dispatch(...a)},r)));function x(n,r){return(e,s,o)=>{let a=!1;typeof r=="string"&&!a&&(console.warn("[zustand devtools middleware]: passing `name` as directly will be not allowed in next majorpass the `name` in an object `{ name: ... }` instead"),a=!0);const h=r===void 0?{}:typeof r=="string"?{name:r}:r;let v;try{v=window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!v)return n(e,s,o);let l=Object.create(v.connect(h)),d=!1;Object.defineProperty(o,"devtools",{get:()=>(d||(console.warn("[zustand devtools middleware] `devtools` property on the store is deprecated it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly"),d=!0),l),set:i=>{d||(console.warn("[zustand devtools middleware] `api.devtools` is deprecated, it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly"),d=!0),l=i}});let _=!1;Object.defineProperty(l,"prefix",{get:()=>(_||(console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names"+h.name===void 0?", pass the `name` option to create a separate instance of devtools for each store.":", because the `name` option already creates a separate instance of devtools for each store."),_=!0),""),set:()=>{_||(console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names"+h.name===void 0?", pass the `name` option to create a separate instance of devtools for each store.":", because the `name` option already creates a separate instance of devtools for each store."),_=!0)}});let u=!0;o.setState=(i,p,t)=>{e(i,p),!!u&&l.send(t===void 0?{type:h.anonymousActionType||"anonymous"}:typeof t=="string"?{type:t}:t,s())};const y=(...i)=>{const p=u;u=!1,e(...i),u=p},m=n(o.setState,s,o);if(l.init(m),o.dispatchFromDevtools&&typeof o.dispatch=="function"){let i=!1;const p=o.dispatch;o.dispatch=(...t)=>{t[0].type==="__setState"&&!i&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),i=!0),p(...t)}}return l.subscribe(i=>{var p;switch(i.type){case"ACTION":if(typeof i.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return O(i.payload,t=>{if(t.type==="__setState"){y(t.state);return}!o.dispatchFromDevtools||typeof o.dispatch=="function"&&o.dispatch(t)});case"DISPATCH":switch(i.payload.type){case"RESET":return y(m),l.init(o.getState());case"COMMIT":return l.init(o.getState());case"ROLLBACK":return O(i.state,t=>{y(t),l.init(o.getState())});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return O(i.state,t=>{y(t)});case"IMPORT_STATE":{const{nextLiftedState:t}=i.payload,f=(p=t.computedStates.slice(-1)[0])==null?void 0:p.state;if(!f)return;y(f),l.send(null,t);return}case"PAUSE_RECORDING":return u=!u}return}}),m}}const O=(n,r)=>{let e;try{e=JSON.parse(n)}catch(s){console.error("[zustand devtools middleware] Could not parse the received json",s)}e!==void 0&&r(e)},U=w("subscribeWithSelector",n=>(r,e,s)=>{const o=s.subscribe;return s.subscribe=(h,v,l)=>{let d=h;if(v){const _=(l==null?void 0:l.equalityFn)||Object.is;let u=h(s.getState());d=y=>{const m=h(y);if(!_(u,m)){const i=u;v(u=m,i)}},(l==null?void 0:l.fireImmediately)&&v(u,u)}return o(d)},n(r,e,s)}),W=w("combine",(n,r)=>(e,s,o)=>Object.assign({},n,r(e,s,o)));var z=Object.defineProperty,T=Object.getOwnPropertySymbols,A=Object.prototype.hasOwnProperty,C=Object.prototype.propertyIsEnumerable,I=(n,r,e)=>r in n?z(n,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[r]=e,S=(n,r)=>{for(var e in r||(r={}))A.call(r,e)&&I(n,e,r[e]);if(T)for(var e of T(r))C.call(r,e)&&I(n,e,r[e]);return n};const b=n=>r=>{try{const e=n(r);return e instanceof Promise?e:{then(s){return b(s)(e)},catch(s){return this}}}catch(e){return{then(s){return this},catch(s){return b(s)(e)}}}},$=w("persist",(n,r)=>(e,s,o)=>{let a=S({getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:t=>t,version:0,merge:(t,f)=>S(S({},f),t)},r),h=!1;const v=new Set,l=new Set;let d;try{d=a.getStorage()}catch{}if(!d)return n((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`),e(...t)},s,o);const _=b(a.serialize),u=()=>{const t=a.partialize(S({},s()));let f;const c=_({state:t,version:a.version}).then(g=>d.setItem(a.name,g)).catch(g=>{f=g});if(f)throw f;return c},y=o.setState;o.setState=(t,f)=>{y(t,f),u()};const m=n((...t)=>{e(...t),u()},s,o);let i;const p=()=>{var t;if(!d)return;h=!1,v.forEach(c=>c(s()));const f=((t=a.onRehydrateStorage)==null?void 0:t.call(a,s()))||void 0;return b(d.getItem.bind(d))(a.name).then(c=>{if(c)return a.deserialize(c)}).then(c=>{if(c)if(typeof c.version=="number"&&c.version!==a.version){if(a.migrate)return a.migrate(c.state,c.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return c.state}).then(c=>(i=a.merge(c,m),e(i,!0),u())).then(()=>{f==null||f(i,void 0),h=!0,l.forEach(c=>c(i))}).catch(c=>{f==null||f(void 0,c)})};return o.persist={setOptions:t=>{a=S(S({},a),t),t.getStorage&&(d=t.getStorage())},clearStorage:()=>{d==null||d.removeItem(a.name)},rehydrate:()=>p(),hasHydrated:()=>h,onHydrate:t=>(v.add(t),()=>{v.delete(t)}),onFinishHydration:t=>(l.add(t),()=>{l.delete(t)})},p(),i||m})}}});
